using Foundry.Domain.Interfaces.EventSourcing;
using Foundry.Domain.Interfaces.Specifications;
using Sample.FinancialMarket.Domain.Aggregates.Orders;
using Sample.FinancialMarket.Domain.Interfaces.Repositories;

namespace Sample.FinancialMarket.Infrastructure.Persistence.Repositories
{
    /// <summary>
    /// Concrete repository for the Order aggregate, using an Event Sourcing persistence strategy.
    /// This repository does NOT use DbContext. Instead, it depends on the IEventStore abstraction.
    /// It is responsible for saving new events and rehydrating the aggregate from its event history.
    /// </summary>
    public class OrderEventSourcedRepository : IOrderRepository
    {
        private readonly IEventStore _eventStore;

        public OrderEventSourcedRepository(IEventStore eventStore)
        {
            _eventStore = eventStore;
        }

        /// <summary>
        /// Retrieves an order by rehydrating it from its event stream, using snapshots for optimization.
        /// </summary>
        public async Task<Order?> GetByIdAsync(Guid id)
        {
            int fromVersion = 0;

            // 1. Create an empty instance of the aggregate to be rehydrated.
            //    This requires the Order class to have a public or internal parameterless constructor.
            var order = new Order();

            // 2. Try to load the latest snapshot to speed up the process.
            var snapshot = await _eventStore.GetLatestSnapshotAsync(id);
            if (snapshot != null)
            {
                order.RestoreFromSnapshot(snapshot);
                fromVersion = snapshot.Version;
            }

            // 3. Get all events that happened *after* the snapshot (or from the beginning if no snapshot).
            var history = await _eventStore.GetEventsForAggregateAsync(id, fromVersion);
            if (!history.Any() && snapshot == null)
            {
                return null; // The aggregate does not exist.
            }

            // 4. Apply the subsequent events to the aggregate to bring it to the current state.
            order.LoadFromHistory(history);

            return order;
        }

        /// <summary>
        /// Saves an aggregate by persisting its uncommitted domain events to the event store.
        /// </summary>
        public async Task AddAsync(Order entity)
        {
            var uncommittedEvents = entity.DomainEvents.ToList();
            if (!uncommittedEvents.Any()) return;

            // Calculate the version of the stream before these new events were applied.
            // This is used for the optimistic concurrency check.
            var originalVersion = entity.CurrentVersion - uncommittedEvents.Count;

            await _eventStore.SaveEventsAsync(entity.Id, uncommittedEvents, originalVersion);
        }

        /// <summary>
        /// In Event Sourcing, "Update" is the same as "Add" from the repository's perspective:
        /// they both just save the new uncommitted events generated by the business logic.
        /// </summary>
        public void Update(Order entity)
        {
            // This is not ideal for async, but it fulfills the IGenericRepository contract.
            // A dedicated IEventSourcedRepository with an async SaveAsync would be an improvement.
            AddAsync(entity).GetAwaiter().GetResult();
        }


        // --- Methods from IGenericRepository that are NOT suitable for a pure Event Sourcing model ---
        // These operations would require building and querying a separate "Read Model" (a projection),
        // which is a core concept of the CQRS pattern that often accompanies Event Sourcing.
        // The framework correctly separates this by having them throw exceptions.

        public Task<IReadOnlyList<Order>> ListAllAsync() =>
            throw new NotImplementedException("List operations on an event-sourced repository require a read model/projection.");

        public Task<IReadOnlyList<Order>> ListAsync(ISpecification<Order> spec) =>
            throw new NotImplementedException("List operations on an event-sourced repository require a read model/projection.");

        public Task<Order?> GetBySpecAsync(ISpecification<Order> spec) =>
            throw new NotImplementedException("Specification-based queries on an event-sourced repository require a read model/projection.");

        public Task<int> CountAsync(ISpecification<Order> spec) =>
            throw new NotImplementedException("Count operations on an event-sourced repository require a read model/projection.");

        public void Remove(Order entity) =>
            throw new NotImplementedException("Hard deletes are an anti-pattern in Event Sourcing. Business logic should raise a 'OrderCancelled' or 'OrderRemoved' event instead.");
    }
}